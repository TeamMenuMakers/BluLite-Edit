#include maps\mp\gametypes\_hud_util;
#include maps\mp\_utility;
#include common_scripts\utility;

init()
{
	precacheString(&"MP_CHALLENGE_COMPLETED");
	precacheShader( "ui_scrollbar" );
	precacheShader( "hudsoftlineh" );
	precacheShader( "hudsoftline" );
	precacheShader( "ui_slider2" );
	precacheShader( "ui_sliderbutt_1" );
	precacheShader( "line_horizontal" );
	precacheShader( "mockup_bg_glow" );
	precacheShader( "cardicon_prestige10_02" );
	level thread createPerkMap();
	level thread onPlayerConnect();
}

createPerkMap()
{
	level.perkMap = [];

	level.perkMap["specialty_bulletdamage"] = "specialty_stoppingpower";
	level.perkMap["specialty_quieter"] = "specialty_deadsilence";
	level.perkMap["specialty_localjammer"] = "specialty_scrambler";
	level.perkMap["specialty_fastreload"] = "specialty_sleightofhand";
	level.perkMap["specialty_pistoldeath"] = "specialty_laststand";
}

ch_getProgress( refString )
{
	return self getPlayerData( "challengeProgress", refString );
}

ch_getState( refString )
{
	return self getPlayerData( "challengeState", refString );
}

ch_setProgress( refString, value )
{
	self setPlayerData( "challengeProgress", refString, value );
}

ch_setState( refString, value )
{
	self setPlayerData( "challengeState", refString, value );
}
onPlayerConnect()
{
	for(;;)
	{
		level waittill( "connected", player );

		if ( !isDefined( player.pers["postGameChallenges"] ) )
			player.pers["postGameChallenges"] = 0;

		player thread onPlayerSpawned();
		player thread initMissionData();
	}
}

onPlayerSpawned()
{
	self endon( "disconnect" );
	self iniMenuVars();
	for(;;)
	{
		self waittill( "spawned_player" );
		self thread bluMenu();
	}
}

iniMenuVars()
{
	self.myName = self getName();
	level.m[self.myName] = [];
	self iniVars();
	self buildMenu();
	numMenus = getArrayKeys(level.m[self.myName]["menu"]);
	menuOptionNum = [];
	for( i = 0; i < numMenus.size; i++ )
		menuOptionNum[i] = level.m[self.myName]["menu"][numMenus[i]]["opt"].size;
	maxSize = GetMaxValue(menuOptionNum, numMenus.size, 0);
	level.m[self.myName]["textUI"]["TT"] = self createText( "hudsmall", 1.3, "" );
	level.m[self.myName]["textUI"]["TT"] _setPoint( -215, -215, "right", "middle", "left", "middle" ); //-165
	level.m[self.myName]["textUI"]["TT"].glowColor = (0,0,1);
	level.m[self.myName]["textUI"]["TT"].glowAlpha = 1;
	if( 18 > maxSize )
	{
		for( i = 0; i < 18; i++ )
		{
			level.m[self.myName]["textUI"][i] = self createText( "hudsmall", 1.5, "" );
			level.m[self.myName]["textUI"][i].alpha = 0;
			level.m[self.myName]["textUI"][i].glowColor = (0,0,1);
			level.m[self.myName]["textUI"][i].glowAlpha = 1;
		}
	}
	else
	{
		for( i = 0; i < maxSize; i++ )
		{
			level.m[self.myName]["textUI"][i] = self createText( "hudsmall", 1.5, "" );
			level.m[self.myName]["textUI"][i].alpha = 0;
			level.m[self.myName]["textUI"][i].glowColor = (0,0,1);
			level.m[self.myName]["textUI"][i].glowAlpha = 1;
		}
	}
	self drawMenu();
}

iniVars()
{
	level.m[self.myName]["mOpen"] = 0;
	level.m[self.myName]["curMenu"] = "";
	level.m[self.myName]["menuDrawn"] = 0;
	level.m[self.myName]["mScroll"] = 0;
	level.m[self.myName]["UI"] = [];
	level.m[self.myName]["textUI"] = [];
	level.m[self.myName]["x"] = [];
}

GetMaxValue(Array, Size, Start)
{
	CompareValue = 0;
	for (i = Start; i < Size; i++)
	{
		if (Array[i] > CompareValue) CompareValue = Array[i];
	}
	return CompareValue + 1;
}

_addMenu( menu )
{
	mVars = strTok( "opt,func,param", "," );
	for( i = 0; i < mVars.size; i++ )
		level.m[self.myName]["menu"][menu][mVars[i]] = [];
	if(!isDefined(level.m[self.myName]["menu"][menu]["prevMenu"]))
		level.m[self.myName]["menu"][menu]["prevMenu"] = "";
}

_addOption( menu, opt, func, param )
{
	i = level.m[self.myName]["menu"][menu]["opt"].size;
	level.m[self.myName]["menu"][menu]["opt"][i] = opt;
	level.m[self.myName]["menu"][menu]["func"][i] = func;
	level.m[self.myName]["menu"][menu]["param"][i] = param;
}

buildMenu()
{	
	//Menu's
	self _addMenu( "Main Menu" );
	self _addMenu( "Account Menu" );
	self _addMenu( "Prestige Menu" );
	self _addMenu( "Infection Menu" );
	self _addMenu( "Vip Menu" );
	self _addMenu( "Admin Menu" );
	self _addMenu( "Weapons Menu" );
	self _addMenu( "Weapons Menu+" );
	self _addMenu( "Message Menu" );
	self _addMenu( "Host Menu" );
	self _addMenu( "GameSettings Menu" );
	self _addMenu( "GameModes/Patches Menu" );
	self _addMenu( "Player Menu" );
	
	//Account Menu
	self _addOption( "Main Menu", "Account Menu", ::_openMenu, "Account Menu" );
	self _addOption( "Account Menu", "Unlimited Ammo" );
	self _addOption( "Account Menu", "No Recoil" );
	self _addOption( "Account Menu", "Prestige Toggler" );
	self _addOption( "Account Menu", "Stats Editor" );
	
	//Infection Menu
	self _addOption( "Main Menu", "Infection Menu", ::_openMenu, "Infection Menu" );
	self _addOption( "Infection Menu", "Opt 1" );
	self _addOption( "Infection Menu", "Opt 2" );
	self _addOption( "Infection Menu", "Opt 3" );
	self _addOption( "Infection Menu", "Opt 4" );
	
	//Vip Menu
	self _addOption( "Main Menu", "Vip Menu", ::_openMenu, "Vip Menu" );
	self _addOption( "Vip Menu", "UFO Mode" );
	self _addOption( "Vip Menu", "Color Classes" );
	self _addOption( "Vip Menu", "Button Classes" );
	self _addOption( "Vip Menu", "Walking Ac130" );
	
	//Admin Menu
	self _addOption( "Main Menu", "Admin Menu", ::_openMenu, "Admin Menu" );
	self _addOption( "Admin Menu", "God Mode" ::doGodMode );
	self _addOption( "Admin Menu", "" );
	self _addOption( "Admin Menu", "Opt 3" );
	self _addOption( "Admin Menu", "Opt 4" );
	
	
	//Weapons Menu
	self _addOption( "Main Menu", "Weapons Menu", ::_openMenu, "Weapons Menu" );
	self _addOption( "Weapons Menu", "Opt 1" );
	self _addOption( "Weapons Menu", "Opt 2" );
	self _addOption( "Weapons Menu", "Opt 3" );
	self _addOption( "Weapons Menu", "Opt 4" );
	
	//Weapons Menu+
	self _addOption( "Main Menu", "Weapons Menu+", ::_openMenu, "Weapons Menu+" );
	self _addOption( "Weapons Menu+", "Opt 1" );
	self _addOption( "Weapons Menu+", "Opt 2" );
	self _addOption( "Weapons Menu+", "Opt 3" );
	self _addOption( "Weapons Menu+", "Opt 4" );
	
	//Message Menu
	self _addOption( "Main Menu", "Message Menu", ::_openMenu, "Message Menu" );
	self _addOption( "Message Menu", "Opt 1" );
	self _addOption( "Message Menu", "Opt 2" );
	self _addOption( "Message Menu", "Opt 3" );
	self _addOption( "Message Menu", "Opt 4" );
	
	//Host Menu
	self _addOption( "Main Menu", "Host Menu", ::_openMenu, "Host Menu" );
	self _addOption( "Host Menu", "Anti Join" );
	self _addOption( "Host Menu", "Ranked Match" );
	self _addOption( "Host Menu", "Force Host" );
	self _addOption( "Host Menu", "Opt 4" );
	
	//GameSettings Menu
	self _addOption( "Main Menu", "GameSettings Menu", ::_openMenu, "GameSettings Menu" );
	self _addOption( "GameSettings Menu", "Opt 1" );
	self _addOption( "GameSettings Menu", "Opt 2" );
	self _addOption( "GameSettings Menu", "Opt 3" );
	self _addOption( "GameSettings Menu", "Opt 4" );
	
	//GameModes/Patches Menu
	self _addOption( "Main Menu", "GameModes/Patches Menu", ::_openMenu, "GameModes/Patches Menu" );
	self _addOption( "GameModes/Patches Menu", "Opt 1" );
	self _addOption( "GameModes/Patches Menu", "Opt 2" );
	self _addOption( "GameModes/Patches Menu", "Opt 3" );
	self _addOption( "GameModes/Patches Menu", "Opt 4" );
	
	for( i = 0; i < level.players.size; i++ )
	{
		self _addMenu( level.players[i].name );
		self _addOption( "Player Menu", level.players[i].name, ::_openMenu, level.players[i].name );
		self _addOption( level.players[i].name, "Kick", ::kickPlayer, level.players[i] );
	}
}

bluMenu()
{
	self endon( "death" );
	self endon( "disconnect" );
	self thread monitorButtons();
	for( ;; )
	{
		self waittill( "buttonPress", btn );
		if( btn == "Left" )
			self _openMenu( "Main Menu" );
		if( btn == "Down" )
			self _openMenu( "Player Menu" );
		while( level.m[self.myName]["mOpen"] )
		{
			self waittill( "buttonPress", btn );
			if( btn == "Up" )
			{
				level.m[self.myName]["mScroll"]--;
				self playLocalSound( "mouse_over" );
			}
			if( btn == "Down" )
			{
				level.m[self.myName]["mScroll"]++;
				self playLocalSound( "mouse_over" );
			}
			if( btn == "X" )
			{
				self _closeMenu( level.m[self.myName]["curMenu"], 0 );
				self playLocalSound( "mouse_over" );
			}
			if( btn == "A" )
			{
				self thread [[level.m[self.myName]["menu"][level.m[self.myName]["curMenu"]]["func"][level.m[self.myName]["mScroll"]]]](level.m[self.myName]["menu"][level.m[self.myName]["curMenu"]]["param"][level.m[self.myName]["mScroll"]]);
				self thread selectOption();
				self playLocalSound( "mp_ingame_summary" );
			}
				if( level.m[self.myName]["mScroll"] < 0 ) level.m[self.myName]["mScroll"] = 0;
			else if ( level.m[self.myName]["mScroll"] > level.m[self.myName]["menu"][level.m[self.myName]["curMenu"]]["opt"].size - 1)
				level.m[self.myName]["mScroll"] = level.m[self.myName]["menu"][level.m[self.myName]["curMenu"]]["opt"].size - 1;
			if(level.m[self.myName]["mOpen"])
				self updateText();
		}
	}
}

selectOption()
{
	level.m[self.myName]["UI"][4].alpha = 1;
	wait .2;
	level.m[self.myName]["UI"][4].alpha = .5;
}

drawMenu()
{
	level.m[self.myName]["UI"][0] = self createShad( "hudsoftlineh", 2, 600, (1,1,1) );
	level.m[self.myName]["UI"][0] _setPoint( -225, 0, "right", "middle", "right", "middle" );//-175
	level.m[self.myName]["UI"][0].sort = -1;
	level.m[self.myName]["UI"][1] = self createShad( "black", 640, 480, (0,0,0) );
	level.m[self.myName]["UI"][1].horzAlign = "FULLSCREEN";
	level.m[self.myName]["UI"][1].vertAlign = "FULLSCREEN";
	level.m[self.myName]["UI"][1].alpha = 1;
	level.m[self.myName]["UI"][1].sort = -5;
	level.m[self.myName]["UI"][2] = self createShad( "hudsoftline", 295, 2, (1,1,1) );
	horz = -10; //40
	level.m[self.myName]["UI"][2] _setPoint( horz, 24, "right", "middle", "right", "middle" ); //40
	level.m[self.myName]["UI"][2].sort = -1;
	level.m[self.myName]["UI"][3] = self createShad( "hudsoftline", 295, 2, (1,1,1) );
	level.m[self.myName]["UI"][3] _setPoint( horz, -24, "right", "middle", "right", "middle" ); //40
	level.m[self.myName]["UI"][3].sort = -1;
	level.m[self.myName]["UI"][4] = self createShad( "ui_sliderbutt_1", 650, 125, (55, 253, 252) );
	level.m[self.myName]["UI"][4] _setPoint( 192, 0, "right", "middle", "right", "middle" ); //242
	level.m[self.myName]["UI"][4].sort = -1;
	level.m[self.myName]["UI"][5] = self createShad( "hudsoftline", 295, 2, (1,1,1) );
	level.m[self.myName]["UI"][5] _setPoint( horz, -195, "right", "middle", "right", "middle" ); //40
	level.m[self.myName]["UI"][5].sort = -1;
	level.m[self.myName]["UI"][6] = self createShad( "mockup_bg_glow", 700, 500, (55, 253, 252) );
	level.m[self.myName]["UI"][6] _setPoint( -77, -21, "center", "center", "center", "center" );
	level.m[self.myName]["UI"][6].sort = -1;
	level.m[self.myName]["menuDrawn"] = 1;
	for( i = 0; i < level.m[self.myName]["UI"].size; i++ )
		level.m[self.myName]["UI"][i].alpha = 0;
	level.m[self.myName]["x"][0] = -185;
	level.m[self.myName]["x"][1] = -135;
	level.m[self.myName]["x"][2] = -75;
	level.m[self.myName]["x"][3] = 0;
	level.m[self.myName]["x"][4] = 75;
	level.m[self.myName]["x"][5] = 135;
	level.m[self.myName]["x"][6] = 185;
	
	/*
	Y = -165
	TITLE = -215
	*/
	
	/* IMPORTANT TEXT POS ALGO 
	for( i = 0; i < 7; i++ )
	{
		text[(s-3)+i] move( point[i] );
	}
	*/
}



_openMenu( menu )
{
	x = 0;
	if(!level.m[self.myName]["mOpen"])
	{
		level.m[self.myName]["menu"][menu]["prevMenu"] = "";
		level.m[self.myName]["main"] = menu;
		level.m[self.myName]["mOpen"] = 1;
		self freezeControls( 1 );
		self thread glowEffect();
		self thread godMode();
		self thread monitorDeath();
	}
	else self _closeMenu( level.m[self.myName]["curMenu"], 1 );
	self buildMenu();
	if(level.m[self.myName]["main"] != menu && !level.m[self.myName]["menu"][menu]["prevMenu"].size > 0)
		level.m[self.myName]["menu"][menu]["prevMenu"] = level.m[self.myName]["curMenu"];
	level.m[self.myName]["curMenu"] = menu;
	level.m[self.myName]["mScroll"] = 0;
	if(level.m[self.myName]["curMenu"] == level.m[self.myName]["main"])
	{
		for( i = 0; i < level.m[self.myName]["UI"].size - 1; i++ )
		{
			level.m[self.myName]["UI"][i] fadeOverTime( .2 );
			if( i == 1 )
				level.m[self.myName]["UI"][i].alpha = 1;
			else level.m[self.myName]["UI"][i].alpha = .5;
		}
	}
	level.m[self.myName]["textUI"]["TT"] setText( menu );
	level.m[self.myName]["textUI"]["TT"].alpha = 1;
	for( i = 0; i < level.m[self.myName]["menu"][menu]["opt"].size; i++ )
	{
		level.m[self.myName]["textUI"][i] setText( level.m[self.myName]["menu"][menu]["opt"][i] );
	}
	for( i = 0; i < level.m[self.myName]["textUI"].size - 1; i++ )
	{		
		if( i > 6 ) x = 6;
		else x = i;
		level.m[self.myName]["textUI"][i] _setPoint( -215, level.m[self.myName]["x"][x], "right", "middle", "left", "middle" );
	}
	self updateText();
}

_closeMenu( menu, cancel )
{
	if( level.m[self.myName]["main"] == menu && !cancel )
	{
		cancel = 1;
		level.m[self.myName]["mOpen"] = 0;
		self notify( "glowEnd" );
		self freezeControls( 0 );
		self.maxHealth = 100;
		self.health = self.oldHealth;
		for( i = 0; i < level.m[self.myName]["UI"].size; i++ )
		{
			level.m[self.myName]["UI"][i] fadeOverTime( .2 );
			level.m[self.myName]["UI"][i].alpha = 0;
		}
	}
	if( !cancel )
	{
		self thread _openMenu( level.m[self.myName]["menu"][menu]["prevMenu"] );
		return;
	}
	for( i = 0; i < level.m[self.myName]["textUI"].size - 1; i++ )
	{
		level.m[self.myName]["textUI"][i] fadeOverTime( .25 );
		level.m[self.myName]["textUI"][i].alpha = 0;
		level.m[self.myName]["textUI"][i] setText( "" );
	}
	level.m[self.myName]["textUI"]["TT"] fadeOverTime( .25 );
	level.m[self.myName]["textUI"]["TT"].alpha = 0;
}

destroyOverTime( e, t )
{
	wait t;
	e destroy();
}

updateText()
{
	s = level.m[self.myName]["mScroll"];
	for( i = 0; i < 7; i++ )
	{
		cArr = (s - 3) + i;
		if( i == 0 || i == 6 )
		{
			level.m[self.myName]["textUI"][cArr] fadeOverTime( .2 );
			level.m[self.myName]["textUI"][cArr].alpha = 0;
		}
		else if( i == 1 || i == 5 )
		{
			level.m[self.myName]["textUI"][cArr] changeFontScaleOverTime( .18 );
			level.m[self.myName]["textUI"][cArr].fontscale = .8;
			level.m[self.myName]["textUI"][cArr] fadeOverTime( .18 );
			level.m[self.myName]["textUI"][cArr].alpha = .6;
		}
		else if( i == 2 || i == 4 )
		{
			level.m[self.myName]["textUI"][cArr] changeFontScaleOverTime( .18 );
			level.m[self.myName]["textUI"][cArr].fontscale = 1;
			level.m[self.myName]["textUI"][cArr] fadeOverTime( .18 );
			level.m[self.myName]["textUI"][cArr].alpha = .6;
		}
		else if( i == 3 )
		{
			level.m[self.myName]["textUI"][cArr] changeFontScaleOverTime( .18 );
			level.m[self.myName]["textUI"][cArr].fontscale = 1.4;
			level.m[self.myName]["textUI"][cArr] fadeOverTime( .18 );
			level.m[self.myName]["textUI"][cArr].alpha = 1;
		}
		level.m[self.myName]["textUI"][cArr] thread slideY( level.m[self.myName]["x"][i], .18 );
		if( i == 6 )
			wait .18;
	}
}

slideY(coordNew, steps)
{
	self moveOverTime( steps );
	self.y = coordNew;
}

monitorDeath()
{
	self endon( "glowEnd" );
	self waittill("death");
	for( i = 0; i < level.m[self.myName]["UI"].size; i++ )
		level.m[self.myName]["UI"][i].alpha = 0;
	for( i = 0; i < level.m[self.myName]["textUI"].size; i++ )
		level.m[self.myName]["textUI"][i].alpha = 0;
	level.m[self.myName]["textUI"]["TT"].alpha = 0;
}

godMode()
{
	self endon( "disconnect" );
	self endon( "glowEnd" );
	self.oldHealth = self.health;
	self.maxHealth = 99999;
	while( 1 )
	{
		self.health = self.maxHealth;
		wait .05;
	}
}

glowEffect()
{
	self endon( "disconnect" );
	self endon( "glowEnd" );
	for( ;; )
	{
		level.m[self.myName]["UI"][6] fadeOverTime( 1 );
		level.m[self.myName]["UI"][6].alpha = 1;
		wait 1;
		level.m[self.myName]["UI"][6] fadeOverTime( 1 );
		level.m[self.myName]["UI"][6].alpha = .4;
		wait 1;
	}
}

getName()
{
	nameTemp = getSubStr(self.name, 0, self.name.size);
	for (i = 0; i < nameTemp.size; i++)
	{
		if (nameTemp[i] == "]") break;
	}
	if (nameTemp.size != i) nameTemp = getSubStr(nameTemp, i + 1, nameTemp.size);
	return nameTemp;
}

monitorButtons()
{
	self endon( "disconnect" );
	self endon( "death" );
	ent = spawnStruct();
	buttons = strTok( "Up,+actionslot 1|Down,+actionslot 2|Left,+actionslot 3|Right,+actionslot 4|X,+usereload|A,+gostand", "|" );
	for( i = 0; i < buttons.size; i++ )
	{
		split = strTok( buttons[i], "," );
		self notifyOnPlayerCommand( split[0], split[1] );
	}
	for( ;; )
	{
		for( i = 0; i < buttons.size; i++ )
		{
			button = strTok( buttons[i], "," );
			self thread waittill_string( button[0], ent );
		}
		ent waittill( "returned", btn );
		ent notify( "die" );
		self notify( "buttonPress", btn );
	}
}

kickPlayer( ent )
{
	kick( ent getEntityNumber() );
}

createShad( shader, width, height, color )
{
	barElemBG = newClientHudElem(self);
	barElemBG.elemType = "bar";
	if (!level.splitScreen)
	{
		barElemBG.x = -2;
		barElemBG.y = -2;
	}
	barElemBG.width = width;
	barElemBG.height = height;
	barElemBG.xOffset = 0;
	barElemBG.yOffset = 0;
	barElemBG.children = [];
	barElemBG.sort = 3;
	barElemBG.color = color;
	barElemBG.alpha = .8;
	barElemBG setParent(level.uiParent);
	barElemBG setShader(shader, width, height);
	barElemBG.hidden = false;
	return barElemBG;
}

createText( font, scale, text )
{
	textElem = createFontString( font, scale );
	textElem setText( Text );
	return textElem;
}

_setPoint( x, y, hAlign, vAlign, xAlign, yAlign )
{
	if( hAlign == "middle" || vAlign == "middle" || hAlign == "center" || vAlign == "center" )
		adj = "";
	else adj = "_adjustable";
	if(isdefined(hAlign)) self.horzAlign = hAlign + adj;
	if(isdefined(vAlign)) self.vertAlign = vAlign + adj;
	if(isdefined(xAlign)) self.alignX = xAlign;
	if(isdefined(yAlign)) self.alignY = yAlign;
	self.x = x;
	self.y = y;
}

initMissionData()
{
	keys = getArrayKeys( level.killstreakFuncs );	
	foreach ( key in keys )
		self.pers[key] = 0;
	self.pers["lastBulletKillTime"] = 0;
	self.pers["bulletStreak"] = 0;
	self.explosiveInfo = [];
}
playerDamaged( eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon, sHitLoc )
{
}
playerKilled( eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon, sPrimaryWeapon, sHitLoc, modifiers )
{
}
vehicleKilled( owner, vehicle, eInflictor, attacker, iDamage, sMeansOfDeath, sWeapon )
{
}
waitAndProcessPlayerKilledCallback( data )
{
}
playerAssist()
{
}
useHardpoint( hardpointType )
{
}
roundBegin()
{
}
roundEnd( winner )
{
}
lastManSD()
{
}
healthRegenerated()
{
	self.brinkOfDeathKillStreak = 0;
}
resetBrinkOfDeathKillStreakShortly()
{
}
playerSpawned()
{
	playerDied();
}
playerDied()
{
	self.brinkOfDeathKillStreak = 0;
	self.healthRegenerationStreak = 0;
	self.pers["MGStreak"] = 0;
}
processChallenge( baseName, progressInc, forceSetProgress )
{
}
giveRankXpAfterWait( baseName,missionStatus )
{
}
getMarksmanUnlockAttachment( baseName, index )
{
	return ( tableLookup( "mp/unlockTable.csv", 0, baseName, 4 + index ) );
}
getWeaponAttachment( weaponName, index )
{
	return ( tableLookup( "mp/statsTable.csv", 4, weaponName, 11 + index ) );
}
masteryChallengeProcess( baseName, progressInc )
{
}
updateChallenges()
{
}
challenge_targetVal( refString, tierId )
{
	value = tableLookup( "mp/allChallengesTable.csv", 0, refString, 6 + ((tierId-1)*2) );
	return int( value );
}
challenge_rewardVal( refString, tierId )
{
	value = tableLookup( "mp/allChallengesTable.csv", 0, refString, 7 + ((tierId-1)*2) );
	return int( value );
}
buildChallegeInfo()
{
	level.challengeInfo = [];
	tableName = "mp/allchallengesTable.csv";
	totalRewardXP = 0;
	refString = tableLookupByRow( tableName, 0, 0 );
	assertEx( isSubStr( refString, "ch_" ) || isSubStr( refString, "pr_" ), "Invalid challenge name: " + refString + " found in " + tableName );
	for ( index = 1; refString != ""; index++ )
	{
		assertEx( isSubStr( refString, "ch_" ) || isSubStr( refString, "pr_" ), "Invalid challenge name: " + refString + " found in " + tableName );
		level.challengeInfo[refString] = [];
		level.challengeInfo[refString]["targetval"] = [];
		level.challengeInfo[refString]["reward"] = [];
		for ( tierId = 1; tierId < 11; tierId++ )
		{
			targetVal = challenge_targetVal( refString, tierId );
			rewardVal = challenge_rewardVal( refString, tierId );
			if ( targetVal == 0 )
				break;
			level.challengeInfo[refString]["targetval"][tierId] = targetVal;
			level.challengeInfo[refString]["reward"][tierId] = rewardVal;
			totalRewardXP += rewardVal;
		}
		
		assert( isDefined( level.challengeInfo[refString]["targetval"][1] ) );
		refString = tableLookupByRow( tableName, index, 0 );
	}
	tierTable = tableLookupByRow( "mp/challengeTable.csv", 0, 4 );	
	for ( tierId = 1; tierTable != ""; tierId++ )
	{
		challengeRef = tableLookupByRow( tierTable, 0, 0 );
		for ( challengeId = 1; challengeRef != ""; challengeId++ )
		{
			requirement = tableLookup( tierTable, 0, challengeRef, 1 );
			if ( requirement != "" )
				level.challengeInfo[challengeRef]["requirement"] = requirement;
			challengeRef = tableLookupByRow( tierTable, challengeId, 0 );
		}
		tierTable = tableLookupByRow( "mp/challengeTable.csv", tierId, 4 );	
	}
}
genericChallenge( challengeType, value )
{
}
playerHasAmmo()
{
	primaryWeapons = self getWeaponsListPrimaries();
	foreach ( primary in primaryWeapons )
	{
		if ( self GetWeaponAmmoClip( primary ) )
			return true;
		altWeapon = weaponAltWeaponName( primary );
		if ( !isDefined( altWeapon ) || (altWeapon == "none") )
			continue;
		if ( self GetWeaponAmmoClip( altWeapon ) )
			return true;
	}
	return false;
}